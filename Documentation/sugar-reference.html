<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>Sugar V0.8.2</title>
<style><!-- 
body {
	margin-left: 10%;
	margin-right: 10%;
	padding: 20pt;
	padding-top: 10pt;
	background: rgb(255,255,255);
	font:  10.5pt/15pt "Helvetica",Helvetica,sans-serif;
	color: rgb(80,80,80);
}

h1, h2, h3, h4 {
	font-family: "Trebuchet MS",Helvetica,sans-serif;
	color: rgb(22, 130, 178);
	font-weight: normal;
	padding-top: 0.5em;
	cursor: pointer;
}

hr {
	color: rgb(150, 220, 238);
	background: rgb(150, 220, 238);
	height: 1px;
	border: 0;
}


b {
	color: rgb(22,130,178);
}

strong {
	color: rgb(103,183,0);
}


a:link, a:active, a:visited {
	color: rgb(22,130,178);
	text-decoration: none;
}

a:hover {
	text-decoration: none;
	background-color: #dbecf4;
}

aimg {
	border: 0;
}

#header, #footer {
	font-size: 7pt;
	clear: both;
	width: 100%;
	color: rgb(177,208,223);
}

.kiwiContent {
	text-align: left;
}


#footer {
	padding-top:  30pt;
	text-align: right;
}

/*  Kiwi-specific  */

.title {
	margin-bottom: 0;
}

.kiwiMeta {
	max-width: 700px;
	padding: 5pt;
	margin-bottom:  2em;
	border-top:  1px solid rgb(150, 220, 238);
	background-color: rgb(250,250,250);
}

.kiwiMeta tr td {
	color: rgb(22, 130, 178);
}

.kiwiMeta tr td.name {
	font-weight: bold;
}

.kiwiContent {
	max-width: 700px;
}

.kiwiContent .heading .number {
	padding-right: 8pt;
}

.kiwiContent .heading .number .lastDot {
	display: none;
}


.kiwiContent .heading .number .level0 .lastDot {
	display: inline;
}

.kiwiContent h1 {
	font-size: 1.8em;
	font-weight: bold;
	margin-top: 1.5em;
	padding-bottom: 0.5em;
	border-bottom:  1px dotted rgb(150, 220, 238);
}

.kiwiContent h2 {
	font-size: 1.4em;
	font-weight: bold;
	padding-bottom: 0.5em;
	border-bottom:  1px dotted rgb(150, 220, 238);
}

.kiwiContent h3 {
	font-size: 1.2em;
	font-weight: normal;
}

.kiwiContent pre {
	padding: 5pt;
	border:  1px solid rgb(150, 220, 238);
	padding-left: 20pt;
	background-color: rgb(240,240,250);
	font-size: 8pt;
	color: rgb(22,130,178);
}

.kiwiContent code {
	font-size: 8pt;
	background-color: rgb(240,240,250);
}

.kiwiContent dt {
	color: rgb(22,130,178);
	font-weight: bold;
}

.kiwiContent dd {
	border-left:  1px solid rgb(150, 220, 238);
	padding-left: 20pt;
	margin-bottom: 2em;
}

.kiwiContent dd pre {
}

.kiwiContent ul {
	padding-top: 0em;
	margin-top: 0em;
}

.kiwiContent ul li {
	padding-bottom: 0.2em;
}

.kiwiContent ul li.todo {
	list-style-type: square;
}

.kiwiContent ul li.todo.done {
	text-decoration: line-through;
}

.kiwiContent table {
	border:  1px solid rgb(150, 220, 238);
	padding: 0pt;
}

.kiwiContent table caption {
	font-family: serif;
	padding-top: 1em;
	padding-bottom: 0.5em;
	font-style: italic;
	font-size: 90%;
	color: rgb(22, 130, 178);
}

.kiwiContent table tbody {
}

.kiwiContent table tr {
	margin: 0;
}

.kiwiContent table tr td {
	margin: 0;
	padding: 5pt;
	font-size: 90%;
	min-width: 125px;
	background-color: rgb(250,250,250);
	border-bottom: 1px solid rgb(150, 220, 238);
}

.kiwiContent table tr td.lastRow {
	border-bottom: none;
}

.kiwiContent table tr td.lastCol {
	border-right: none;
}

.kiwiContent table tr.even td {
	background-color: #FEFEFE;

}

.kiwiContent table tr.odd td {
	background-color: rgb(240,240,240);
}

.kiwiContent .term {
	color: rgb(22, 130, 178);
	background: rgb(240, 250, 256);
}

.kiwiContent .quote {
	font-style: italic;
	color: rgb(120, 120, 120);
}

.kiwiContent .citation {
	font-style: italic;
	color: rgb(120, 120, 120);
}

.kiwiContent div[class^="ann"] {
	margin-top: 5pt;
	margin-bottom: 5pt;
	padding: 5pt;
	padding-left: 20pt;
	color: rgb(100, 100, 100);
}

.kiwiContent div[class^="ann"] .title {
	font-weight: bold;
}

.kiwiContent .annNote {
	border:  1px solid rgb(103,183,0);
	margin-top: 5pt;
	margin-bottom: 5pt;
	padding: 5pt;
	padding-left: 20pt;
	background: #fffbe4;
	color: rgb(100, 100, 100);
	border:  1px solid #dedac3;
}

.kiwiContent .annNote .title {
	font-weight: bold;
	display: none;
}

.kiwiReferences {
	font:  8pt/12pt "Lucida Grande",Lucida,sans-serif;
	margin-top: 10pt;
	padding: 5pt;
	border-top:  1px solid rgb(200, 200, 200);
	background-color: rgb(250,250,250);
	color: rgb(200, 200, 200);
	font-size: 8pt;
}
.kiwiReferences a:link, .kiwiReferences a:active, .kiwiReferences a:visited {
	color: rgb(150,150,150);
}

.kiwiReferences .entry {
	padding-top: 5pt;
	clear: both;
}

.kiwiReferences .entry .name {
	float: left;
	font-weight: bold;
	padding-right: 5pt;
}

.kiwiReferences .entry .content {
	text-align: right;
}

 --></style>
</head>
<body>
<div
	class="title"><h1>Sugar V0.8.2</h1><h2>Language Reference</h2></div><table class='kiwiMeta'><tr><td width='0px' class='name'>Author</td><td width='100%' class='value'>Sebastien Pierre &lt;sebastien@ivy.fr&gt;</td></tr><tr><td width='0px' class='name'>Revision</td><td width='100%' class='value'>23-Oct-2007 (21-Aug-2007)</td></tr></table>
<div class="kiwiContent"><div class='content'><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">1<span class="lastDot dot">.</span></span></span>About Sugar</h1><div class="level1"><p>Main thing:</p><ul><li>Simple semantics </li><li>Syntax as clear as possible</li></ul><ul><li>Code as data </li><li>Meta-programming (compiled and interpreted) </li><li>Plastic </li><li>Dynamic, Reflexive </li><li>Concurrency </li><li>Advanced type system </li><li>Compiles to many backends (JavaScript, ActionScript, Python, Pnuts)</li></ul><p>Benefits (of relying on LambdaFactory):</p><ul><li>Write your own DSL or custom syntax </li><li>Easy to refactor </li><li>You can manipulate your code</li></ul></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">2<span class="lastDot dot">.</span></span></span>Syntax</h1><div class="level1"><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">1<span class="lastDot dot">.</span></span></span>Basics</h2><div class="level2"><ul><li>Case sensitive </li><li>Indentation matters </li><li>Tabs are required</li></ul></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">2<span class="lastDot dot">.</span></span></span>Design</h2><div class="level2"><ul><li>Short learning curve for JavaScript, Python or Ruby programmers </li><li>Be explicit </li><li>Limit possibilities of variations between coding styles </li><li>Easy to parse, easy to write tools</li></ul></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">3<span class="lastDot dot">.</span></span></span>Expressions and statements</h2><div class="level2"><p>In Sugar, most constructs are <span class='term'>expressions</span> (they can be evaluated, meaning they can be substituted to a value) something). Expressions can be as simple as computations, or as complex as function declarations. Here is a list of expressions:</p><ul><li>Computation </li><li>Invocation </li><li>Literal declaration (strings, numbers, primitive types) </li><li>Anonymous function declaration </li><li>Inline conditional</li></ul><p>On the other hand, <span class='term'>statements</span> are operations that do not substitute to a value (as opposed to expressions). These operations typically trigger language-specific side effects, such as returning a result, raising an exception, etc. Sugar statements are:</p><ul><li>Allocation (declaring a variable) </li><li>Assignment (assigning a value to a variable) </li><li>Termination (return statement) </li><li>Interruption (raising an exception) </li><li>Control structures (most conditionals, loops, etc)</li></ul><p><span class='term'>type expressions</span> (see <a href="#TYPE-SYSTEM" class="internal">type system</a>()).</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">4<span class="lastDot dot">.</span></span></span>Keywords</h2><div class="level2"><p>Sugar defines a set of keywords that should be avoided as naming elements (variables, functions, etc).</p><pre>var                                       (variable declaration)
as and or not has is in                   (operators)
new                                       (instanciation)
if else                                   (conditionals)
for while                                 (iterations/repetitions)
return break continue yield raise         (control flow manipulation)
end                                       (syntax block terminator)</pre><div class='annNote'><div class='title'>note</div><div class='content'>
  Sugar default parser is rather flexible, so for instance you can name a
  variable <code>end</code>, though it is a keyword, and the parser will figure out whether
  it's the keyword or a variable.</div></div></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">5<span class="lastDot dot">.</span></span></span>Symbols</h2><div class="level2"><p>Symbols are elements that allow abstraction from values. For instance, when you say <code>a = 1</code>, you say that the symbol <code>a</code> abstracts the value <code>1</code>, and we can then say that the symbol <code>a</code> can be <span class='term'>evaluated</span> to <code>1</code>.</p><p>Anyway, symbols are used everywhere do declare and references variables, functions, classes, modules, etc.</p><p>Symbols in Sugar are sequence of characters that:</p><ul><li>Start with any of these <code>_$</code> or letters </li><li>Are composed of any letter, digit or any of <code>_$</code></li></ul><p>Here are example uses of symbols</p><pre>var a                                      # (variable declaration)
a + 10                                     # (computation)
@function f                                # (class declaration)</pre></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">6<span class="lastDot dot">.</span></span></span>Literals</h2><div class="level2"><p>Literals are values that can be fully described when they are declared. Literals include numbers, strings and primitive data-types such as lists and dictionaries (yes, Sugar is a modern language !).</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">7<span class="lastDot dot">.</span></span></span>Numbers</h2><div class="level2"><p>Number are either <span class='term'>integers</span> or <span class='term'>floats</span>, expressed using various notations:</p><pre>1                                          # (integer)
-10                                        # (integer)
1.0                                        # (float)
 .0                                        # (float)
-2.0                                       # (float)
0xFFEE00                                   # (integer in hexadecimal)</pre><p>Strings are the same as in C, excpeted that you can use both single and double quotes to delimit the string (syntax additions coming soon !):</p><pre>"Hello, World"                             # (double quote)
'Hello, World'                             # (single quote)
'Hello, "World" !'                         # (single quote)
"Hello, \"World\" !"                       # (escaping)</pre><div class='annNote'><div class='title'>note</div><div class='content'>
    There is no way right now to define an encoding for the string (no unicode
    string support).</div></div></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">8<span class="lastDot dot">.</span></span></span>Lists</h2><div class="level2"><p>Sugar also supports lists and dictionaries as literal (we call them <span class='term'>primitive compound types</span>):</p><pre>[]
[1,2,3]
[1,2,3,["a", "b", "c", "d"]]</pre><p>Lists can have any value in them (this includes lists, of course).</p><pre>[]
["one",2]
[1,[2,[3,[4]]]]</pre></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">9<span class="lastDot dot">.</span></span></span>Dictionaries</h2><div class="level2"><p>Dictionaries are defines as a comma-separated <code>KEY : VALUE</code> list. The key is a regular sugar <span class='term'>symbol</span>:</p><pre>{one:1, two:2}</pre><p>or can be an <span class='term'>expression</span> when the key is surrounded by parentheses:</p><pre>{("o" + "ne"):1, ("tw" + "o"):2}
{(1):1, (2):2, (3):3}</pre><p>Dicts can have any value in them (this includes dicts and lists, of course).</p><pre>{}
{one:1,two:2,three:3}
{id:0,attributes:{name:"Bob",email:"bob@email.org"}}</pre><div class='annNote'><div class='title'>note</div><div class='content'>_
    Some back-ends may not support declaration of dictionaries with expressions
    as keys (but the main ones do !). In this case, an error will be produced at
    program translation time.</div></div><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">9<span class="dot">.</span></span><span class="level2">1<span class="lastDot dot">.</span></span></span>Symbolic values</h3><div class="level3"><p>Symbolic values are specific values of the programming language like <code>None</code> in Python or <code>null</code> or <code>undefined</code> in JavaScript. They represent singleton values.</p><p>Sugar defines the following symbolic values:</p><ul><li><code>Undefined</code> allowing to denote something that is not defined yet (typically a declared variable that has not been affected a value)</li></ul><ul><li><code>None</code>, representing the absence of value (typically the value returned by functions returning no other value).</li></ul><ul><li><code>True</code>, the well-known and well-named (typically something not false ;)</li></ul><ul><li><code>False</code>, the well-known and well-named (typically something not not false ;)</li></ul><ul><li><code>NaN</code>, a value indicating that a computation went bad (typically used when you express some computation that was not computable).</li></ul><ul><li><code>Error</code>, can be used to indicate that an error happened in a process (typically used in asynchronous programming and pattern-matching)</li></ul><ul><li><code>Success</code> indicates that a process succeeded (typically used in asynchronous programming and pattern-matching)</li></ul><ul><li><code>Timeout</code> indicates that a timeout happened in a process (typically used in asynchronous programming and pattern-matching)</li></ul><ul><li><code>_</code> which is the well-known &ldquo;<span class='quote'>joker</span>&rdquo; symbol from Prolog (see <a href="#PATTERN-MATCHING" class="internal">pattern-matching</a>())</li></ul><p>This may seem like a lot of values, but it's a good thing to learn them and understand their role. You'll find this very useful in the long run !</p></div></div><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">9<span class="dot">.</span></span><span class="level2">2<span class="lastDot dot">.</span></span></span>Allocations</h3><div class="level3"><p>Values have to be bound to symbols to be usable in the program. Variables represent <span class='term'>slots</span> (think of a named box to put stuff in) that can hold values, and can be referenced with a <span class='term'>symbol</span> (the variable name).</p><p>Slots are <span class='term'>allocated</span> by declaring a variable (a symbol that will represent the slot) using the <code>var</code> keyword:</p><pre>var SYMBOL                                 # (allocation)</pre><p>An initial value can be <span class='term'>bound</span> to the slot. This value is represented by an expression. The operation that will evaluate the expression and bind the resulting value to the slot is called an <span class='term'>assignment</span>.</p><pre>var SYMBOL = EXPRESSION                    # (allocation and assignment)</pre><p>in practice:</p><pre>var fruits = ["apple", "cherry", "banana"]</pre><p>if declare a slot without a value, its value will be <code>Undefined</code></p><pre>var fruits</pre><p>When declaring a slot, you have the opportunity to associate a <span class='term'>type declaration</span> with the slot:</p><pre>var SYMBOL:TYPE (=EXPRESSION)?             (type declaration)</pre><p>the <code>TYPE</code> declaration is a type expression that allows to constrain the usage of the slot. We'll talk about this in more detail in the <a href="#TYPE-SYSTEM" class="internal">type system</a>section. As a simple illustration:</p><pre>var fruits:List</pre><p>will indicate that the <code>fruits</code> symbol references a slot which values must be compatible with type <code>List</code>. If you try to <span class='term'>assign</span> a number or a string to <code>fruits</code>, you'll have a warning (if the compiler is not too strict) or an error.</p><p>Allocations also support the declaration of multiple variables at once as well as the assignment of &ldquo;<span class='quote'>slices</span>&rdquo; of a value. We'll detail multiple variables declaration here, but leave the <span class='term'>slices assignment</span> to the next section.</p><p>So multiple values can be declared like this</p><pre>var a,b                                    # (multiple allocations)
var a=1,b=2b                               # (mult. alloc. and assign.)
var a:List, b=2, c:String="Hello"          # (mult. alloc. with type)</pre><p>in general you can put multiple <code>var</code> declarations in one single line using this syntax. However, we recommend to only use it for simple cases where you only assign literals:</p><pre>var one=1, two=2</pre><p>Summary:</p><pre>var SYMBOL                                 (allocation)
var SYMBOL:TYPE                            (allocation + type)
var SYMBOL = EXPRESSION                    (allocation + assignment)
var SYMBOL:TYPE = EXPRESSION               (allocation + type + assignment)
var SYM:TYP=EXP, SYM:TYP=EXP, ...          (multiple alloc+type+assign)</pre></div></div><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">9<span class="dot">.</span></span><span class="level2">3<span class="lastDot dot">.</span></span></span>Assignments</h3><div class="level3"><p>Assignments are actually a subset of allocations in the sense that allocations both allocate a slot, and assign a value (bind the value to the slot). In this respect, they share the same syntax, excepted that you have the <code>var</code> keyword prefix for allocations.</p><p>Assignments in Sugar are made using the <code>=</code> operator:</p><pre>SYMBOL = EXPRESSION                        (assignment)</pre><p>here is a very trivial example.</p><pre>fruits = ["orange", "pear", "tangerine"]</pre><p>this is a perfect example to introduce the <span class='term'>slices assignment</span> we mentioned earlier. Some values may provide support for slicing (<code>[1,2,3]</code> can be sliced in <code>1</code>, <code>2</code>, <code>3</code>), in which case the slices can be directly assigned to variables:</p><pre>orange, pear, tangerine = ["orange", "pear", "tangerine"]</pre><p>will assign <code>"orange"</code> to <code>orange</code>, and <code>"pear"</code> to <code>pear</code> (ha !) and <code>"tangerine"</code> to <code>tangerine</code>. However:</p><pre>orange, pear_tangerine = ["orange", "pear", "tangerine"]</pre><p>will fail because there is one more element that was not assigned.</p><div class='annNote'><div class='title'>note</div><div class='content'>
    When using slices assignment, you have to make sure that every slice is
    assigned to a variable. This limits the practical use cases for that to the
    places where you are sure of the type of expression you assign from.</div></div><p>Sugar offers an alternative syntax for the <span class='term'>slices assignment</span> that allows you to care less about the number of slices: this:</p><pre>orange | pear_tangerine = ["orange", "pear", "tangerine"]</pre><p>will assign <code>"orange"</code> to <code>orange</code>, and <code>pear_tangerine</code> will be assigned with the <span class='term'>rest</span> of the expression:<code>["pear","tangerine"]</code>. This is something that people coming from functional programming languages will be familiar with.</p><p>The <code>|</code> in the assignment meaning the rest, you can combine <code>,</code> and <code>|</code> in one statement:</p><pre>orange, pear | tangerine = ["orange", "pear", "tangerine"]</pre><p>in which case <code>orange</code> will be <code>"orange"</code>, <code>pear</code> will be <code>"pear"</code> and <code>tangerine</code> will be <code>["tangerine"]</code> (the rest being always a list or a subset of the original container).</p><p>If you ask the rest of an empty list, you'll have 'None'</p><pre>orange | pear = ['orange']</pre><p>in this case, <code>pear</code> will be <code>None</code>, and you won't get any error. However, if you do</p><pre>orange, pear | tangerine = ['orange']</pre><p>you will have an error because your expression won't have enough slices</p><div class='annNote'><div class='title'>note</div><div class='content'><span class='term'> When using the </span>rest_ operator, you still have to make sure that your
    expression has as many slices as there are symbols before the rest
    operators, otherwise the assignment won't be able to complete.</div></div><p>As mentioned in <a href="#ALLOCATIONS" class="internal">allocations</a>(), you can simply prefix assignments with <code>var</code> to turn the assignments into allocations and assignments.</p><p>Summary:</p><pre>SYMBOL = EXPRESSION                        (single assignment)
SYMBOL (,SYMBOL)* = EXPRESSION             (spice assignment)
SYMBOL (,SYMBOL) | SYMBOL = EXPRESSION     (slice assignment with rest)</pre></div></div><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">9<span class="dot">.</span></span><span class="level2">4<span class="lastDot dot">.</span></span></span>Computations</h3><div class="level3"><p>Computations are what everybody's most familiar with: basic arithmetic operations applied to values. Each computation uses an operator, chosen among the following list:</p><ul><li>an arithmetic operator: <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>^</code> <code>%</code> </li><li>a comparison operator: <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>!=</code> </li><li>a logic operator: <code>and</code>, <code>or</code>, <code>not</code> </li><li>specific operators: <code>is</code>, <code>isa</code>, <code>like</code>, <code>has</code></li></ul><p>most operators take two operands, excepted the <code>not</code> operator which only takes one operand to its right. The general form of computations is as follows:</p><pre>OPERATOR EXPRESSION                        (single-operand operation)
EXPRESSION OPERATOR EXPRESSION             (operation with two operands)</pre><div class='annNote'><div class='title'>note</div><div class='content'>
    Sugar does not define suffix operations (like <code>--</code> or <code>++</code> as in C), but we
    may add them as a later point. There are not bit-manipulation operators
    (<code>||</code> <code>&amp;&amp;</code>, <code>&lt;&lt;</code> and ''&gt;&gt;') yet.</div></div><p>Here are example of operations using <span class='term'>arithmetic operators</span>:</p><pre>1 + 1                                      (addition)
5 * 2                                      (multiplication)
5 ^ 2                                      (power)
5 / 2                                      (division)
5 % 2                                      (modulo)</pre><p>here are <span class='term'>comparison operators</span>:</p><pre>1 &lt; 2                                      (smaller than)
2 &gt; 2                                      (greater than)
1 &lt;= 2                                     (smaller or equal to)
1 &gt;= 2                                     (greater or equal to)
1 == 1                                     (equal to)
5 != 2                                     (not equal to)</pre><p>here are <span class='term'>logic operators</span>:</p><pre>not True                                   (negation)
True or False                              (logical union)
True and False                             (logical intersection)</pre><p><span class='term'>specific operators</span> have a semantic that will be detailed later in the <a href="#OBJECT-MODEL" class="internal">object model</a>() section. They are all related to doing queries on values (and objects in particular):</p><ul><li><span class='term'>value identification</span> allows to tell whether two values are actually the exact same object.</li></ul><ul><li>value approximation_ allows to tell whether two values are &ldquo;<span class='quote'>like</span>&rdquo; each other (they do not need to be the exact same, but should be used interchangeably)</li></ul><ul><li><span class='term'>object type identification</span> allows to tell whether the given value/object is of the given type/class. This is basically what <code>instanceof</code> do in other languages.</li></ul><ul><li><span class='term'>object slot querying</span> allows to tell if an object defines a particular slot (even if the slot value is <code>Undefined</code>).</li></ul><pre>object_a is object_b                       (value identification)
object_a isa ObjectClass                   (value type identification)
object_a like object_b                     (value approximation)
object has name                            (slot querying)</pre><p>Additionally, it is possible to combine assignment and operations for a subset of arithmetic operations:</p><pre>a += 1                                     (a = a + 1)
a -= 1                                     (a = a - 1)</pre><p>Summary:</p><pre>OPERATOR EXPRESSION                        (single-operand operation)
EXPRESSION OPERATOR EXPRESSION             (operation with two operands)
SYMBOL += EXPRESSION                       (assignment with addition)
SYMBOL -= EXPRESSION                       (assignment with substraction)</pre></div></div><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">9<span class="dot">.</span></span><span class="level2">5<span class="lastDot dot">.</span></span></span>Invocations</h3><div class="level3"><p>An invocation is the application of a set of values to another value (a function) that can be invoked (we call them <span class='term'>invocables</span>). The invocation will typically result in a value (the invocation is then an expression, as it &ldquo;<span class='quote'>evaluates to a value</span>&rdquo;).</p><p>In Sugar, invocations have a very common syntax:</p><pre>EXPRESSION ( EXPRESSION, EXPRESSION, EXPRESSION, ... )</pre><p>where the first <code>EXPRESSION</code> must (of course) evaluate to something that can be invoked. These expression are typically references to functions, which we'll introduce <a href="functions" class="external">soon</a>.</p><p>The <code>EXPRESSION</code>s within parentheses are the (actual) <span class='term'>arguments</span> (parameters) to the invocable (function).</p><p>When your invocation has long expressions as arguments, Sugar allows you to make the invocation span multiple lines:</p><pre>EXPRESSION ( EXPRESSION, EXPRESSION,
&lt;tab&gt;EXPRESSION
)</pre><p>when using newlines, you can omit the trailing comma on the first line (but) trailing commas on the body lines aren't allowed:</p><pre>EXPRESSION ( EXPRESSION
&lt;tab&gt;EXPRESSION
)</pre><p>also, you're not forced to put an argument after the opening paren:</p><pre>EXPRESSION (
&lt;tab&gt;EXPRESSION
&lt;tab&gt;EXPRESSION
)</pre><p>Sugar also provides way to indicate <span class='term'>named arguments</span>, in case you'd like to specify the arguments out of order. Here is how to do this</p><pre>EXPRESSION (SYMBOL=EXPRESSION,...)         # (named arguments)</pre><p>and here is an example of two similar invocations:</p><pre>juice( "orange", spice="cinnamon", blend="thin" )
juice( "orange", blend="cinnamon", spice="thin" )</pre><p>When using <span class='term'>named</span> arguments, you have to make sure they appear after the non-named arguments.</p><p>Sugar also offers a way to specify optional arguments as a list</p><pre>EXPRESSION (...EXPRESSION)                 # (optional arguments)</pre><p>in practice:</p><pre>var fruits = ["apple", "orange", "tangerine")
juice(...fruits)</pre><p>will be equivalent to</p><pre>juice("apple", "orange", "tangerine")</pre><p>you can do the same with named arguments:</p><pre>EXPRESSION (...=EXPRESSION)                # (optional arguments)</pre><p>in practice:</p><pre>var fruits = {fruit:"orange", spice="cinnamon", blend="thin")
juice(...=fruits)</pre><p>will be equivalent to</p><pre>juice(fruit="orange", spice="cinnamon", blend="thin")</pre><p>When using <code>...</code> or <code>...=</code>, you have to make sure they are the last to appear in the arguments. When both are used <code>...=</code> should be the last. Here is a complete example:</p><pre>fooize("orange", ...(["tangerine", "cherry"]), ...=({spice:"cinnamon}))</pre><div class='annNote'><div class='title'>note</div><div class='content'>
    It may be useful to note that some (or most) functions may not accept extra
    named or unnamed parameters. Have a look at the <a href="#FUNCTIONS" class="internal">functions</a>section to know
    a little bit more about the why.</div></div><p>Summary:</p><pre>EXPRESSION()                               (invocation w/o arguments)
EXPRESSION(EXPRESSON)                      (invocation w/ argument)
EXPRESSION(SYMBOL=ARGUMENTS)               (name arguments)
EXPRESSION(...ARGUMENTS)                   (optional arguments)
EXPRESSION(...=ARGUMENTS)                  (optional named arguments)
EXPRESSION(ARG,...ARG,...=ARG)             (combination)

EXPRESSION(                                (multi-line invocation)
&lt;tab&gt;EXPRESSION
)</pre></div></div><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">9<span class="dot">.</span></span><span class="level2">6<span class="lastDot dot">.</span></span></span>Anonymous functions</h3><div class="level3"><p>Sugar allows <span class='term'>anonymous functions</span> to be defined and used a values, like numbers, strings, lists and dictionaries. An anonymous function is composed of a set of statements (the function <span class='term'>body</span>) as well as the specification of the function <span class='term'>arguments</span>:</p><pre>{ ARGUMENT, ARGUMENT | STATEMENTS }</pre><p>the list of arguments can be empty, in which case you can write the function as follows (provided it cannot be mis-interpreted with a dictionary literal).</p><pre>{ STATEMENTS }</pre><p>As Sugar is quite strict about whitespace, the <code>STATEMENTS</code> have to follow a very specific scheme:</p><pre>var SYMBOL                                 (allocation)
{ ARGUMENTS | STATEMENT ; STATEMENT }      (one-liner)

{ ARGUMENTS | STATEMENT                    (more than one line)
&lt;tab&gt;STATEMENT
}

{ ARGUMENTS |                              (more than one line variant)
&lt;tab&gt;STATEMENT
}</pre><p>this syntax is designed to enforce a consistent presentation of anonymous functions.</p><p>Also, Sugar <span class='term'>anonymous functions</span> are actually <span class='term'>closures</span>, meaning that you can use variables defined in the enclosing scope. When you use these variables, they reference the value of the variable at the time of the function declaration, not invocation.</p><pre>var a = 1
var f = { return a }
a = 10
f() == 1                                   (will evaluate 'True')</pre><p>in a sense, variables implicitly referenced in anonymous function could be rewritten as:</p><pre>var a = 1
var f = { var a=1 ; return a }</pre><div class='annNote'><div class='title'>note</div><div class='content'>
    To the difference of other languages (JavaScript, for instance),
    referencing and re-assigning an external variable from within a closure
    won't affect the external variable. External variables are actually copied
    in the scope of the closure, exactly as illustrated by the above example.</div></div><p>Summary:</p><pre>{|}                                        (empty function)
{ARGUMENT|STATEMENT}                       (single argument and statement)
{A1,A2,A3|STATEMENT}                       (multi arg. single statement)
{A1,A2,A3|S1;S2;S3}                        (multi argument and statement)</pre></div></div><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">9<span class="dot">.</span></span><span class="level2">7<span class="lastDot dot">.</span></span></span>Function declaration</h3><div class="level3"><p>Functions in Sugar are a bit different from Anonymous Functions/Closures, both from their syntax and semantics. Functions are only defined within <span class='term'>modules</span> (we'll see them soon) and don't &ldquo;<span class='quote'>close</span>&rdquo; on their environment as closures do.</p><p>From a syntactic point of view, functions are a little bit more verbose:</p><pre>@function f
  print ("Hello, World !")
@end</pre><p>Which is less compact than the closure-equivalent:</p><pre>{print ("Hello, World !")}</pre><p>So functions are always declared by using the following form</p><pre>@function NAME ARG, ARG=VAL, REST..., KWARGS=...
&lt;INDENT&gt; STATEMENT
&lt;INDENT&gt; ...
@end</pre><p>First thing to notice here is that the function <span class='term'>body</span> (the statements within the function) has to be indented (use tabs !), and that the function declaration ends explicitly with the <code>@end</code> keyword.</p><p>This is a common pattern in Sugar syntax, where declarations always start with <code>@something</code>, have an indented body and end with <code>@end</code>.</p><p>You'll notice that the above function declaration has different syntaxes for the argument, which all denote a specific role for the argument:</p><ul><li><code>ARG</code> is a &ldquo;<span class='quote'>standard</span>&rdquo; argument </li><li><code>ARG=VAL</code> is an argument with a <span class='term'>default value</span> </li><li><code>ARGS...</code> is an argument that represents the rest of the arguments </li><li><code>ARGS=...</code> is an argument that represents the rest of the named parameters passed at invocation time.</li></ul><p>Those knowing Python won't find this difficult to understand, but this may need some explanation. Imagine you have</p><pre>@function f a, b=1, args..., kwargs...
    ...
@end</pre><p>and you do this successive invocations</p><pre>f(1)                                       [1]
f(1,2)                                     [2]
f(1,2,3)                                   [3]
f(1,2,3,4)                                 [4]
f(a=1,b=2)                                 [5]
f(a=1,b=2,c=3)                             [6]
f(1,2,3,d=4)                               [7]</pre><p>You'll have:</p><ul><li>in case 1, <code>a</code> as <code>1</code>, b as <code>1</code>, <code>args</code> as <code>[]</code> and <code>kwargs</code> as <code>{}</code> </li><li>in case 2, <code>a</code> as <code>1</code>, b as <code>2</code>, <code>args</code> as <code>[]</code> and <code>kwargs</code> as <code>{}</code> </li><li>in case 3, <code>a</code> as <code>1</code>, b as <code>2</code>, <code>args</code> as <code>[3]</code> and <code>kwargs</code> as <code>{}</code> </li><li>in case 4, <code>a</code> as <code>1</code>, b as <code>2</code>, <code>args</code> as <code>[3,4]</code> and <code>kwargs</code> as <code>{}</code> </li><li>in case 5, <code>a</code> as <code>1</code>, b as <code>2</code>, <code>args</code> as <code>[]</code> and <code>kwargs</code> as <code>{}</code> </li><li>in case 6, <code>a</code> as <code>1</code>, b as <code>2</code>, <code>args</code> as <code>[]</code> and <code>kwargs</code> as <code>{c:3}</code> </li><li>in case 6, <code>a</code> as <code>1</code>, b as <code>2</code>, <code>args</code> as <code>[3]</code> and <code>kwargs</code> as <code>{c:3}</code></li></ul><p>The pattern here is rather simple:</p><ul><li><code>args</code> and <code>kwargs</code> both represents extra arguments that were not formally named in the function declaration </li><li><code>args</code> will contain the list of extra arguments passed without names at invocation time (see <a href="#INVOCATIONS" class="internal">invocations</a>) </li><li><code>kwargs</code> will contain the list of extra arguments passed with names at invocation time.</li></ul><p>Note that if you specify both <code>ARGS...</code> and <code>ARGS=...</code>, <code>ARG...</code> must come first. Also if you don't specify 'ARGS&hellip;<code> your function won</code>t accept an invocation with a different number of unnamed parameters, and if you don't specify 'ARGS=&hellip;<code> in you function, it won</code>t accept an invocation with extra named parameters.</p><p>Summary:</p><pre>@function NAME ARG, ARG, ARG               (function declaration start)
&lt;tab&gt;STATEMENT                             (function body)
@end                                       (function declaration end)
ARG                                        (unnamed argument)
ARG:TYPE                                   (unnamed typed argument)
NAME=ARG                                   (named argument)
NAME:TYPE=ARG                              (named typed argument)
ARGS...                                    (extra unnamed arguments)
ARGS=...                                   (extra named arguments)</pre></div></div><div class="section" level="3"><h3 class="heading"><span class="number"><span class="level0">2<span class="dot">.</span></span><span class="level1">9<span class="dot">.</span></span><span class="level2">8<span class="lastDot dot">.</span></span></span>An example</h3><div class="level3"><p>We've finished the first important section of this manual, and you should now have a good idea of the basics of Sugar. Here is an example that sums up what we've learned so far:</p><pre>TODO</pre></div></div></div></div></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">3<span class="lastDot dot">.</span></span></span>Object model</h1><div class="level1"><p>Sugar was designed as an object-oriented programming language, because it's hard to live without objects when you do software engineering. Sugar object-model is <span class='term'>class-based</span> (as opposed to <span class='term'>prototype-based</span>) and is very similar to what you know from commonly practiced OO languages such as Java, C++, C#, Python or Ruby.</p><p>As Sugar was designed as an easy-to-learn language for people familiar with existing OO languages, we decided not to use (by default) something more elegant (but trickier) such as prototypes.</p><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">1<span class="lastDot dot">.</span></span></span>LambdaFactory and hosts</h2><div class="level2"><p>It's good to recall that Sugar is merely a syntax for the LambdaFactory program modeling API. In that sense, Sugar only provide a &ldquo;<span class='quote'>syntactic sugar</span>&rdquo; (no pun intended ;) to the creation of a LambdaFactory program tree.</p><p>The side-effect of that, is that most of the properties of the object model are left up to the host language to which LambdaFactory trees can be translated.</p><p>If you translate to Python, you'll have an actual class-based object model, but if you translate to JavaScript, you'll have a class-based object model sitting on top of a prototype-based object model.</p><p>LambdaFactory runtime provides support for class-based OO model for every host language it supports, so that in practice, you don't have to think too much about what language your Sugar code will be translated to.</p></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">2<span class="lastDot dot">.</span></span></span>Objects</h2><div class="level2"><p>Objects in Sugar are conceptually viewed as &ldquo;<span class='quote'>entities communicating by message-passing</span>&rdquo;, which is basically the definition that Smalltalk people would give for objects. In practice, Sugar gives you objects which are &ldquo;<span class='quote'>a state and a set of operations to access and manipulate this state</span>&rdquo;, which is more like the Java/C++ definition of objects.</p><p>Again, as Sugar relies on LambdaFactory, which itself abstracts from different programming-languages (&ldquo;<span class='quote'>hosts</span>&rdquo;), the actual object model depends on the model provided by the &ldquo;<span class='quote'>host</span>&rdquo;.</p><p>So, to make a long story short, object are composed of:</p><ul><li>a <span class='term'>state</span>, which is the aggregation of the object <span class='term'>attributes</span> </li><li><span class='term'>operations</span>, which is the collection of the <span class='term'>methods</span> available to the object</li></ul><p>Objects also carry <span class='term'>type information</span>, but this is something that we'll cover in the next section. In the class-based object model, the basic object type information is simply being able to get the <span class='term'>class</span> to which the object belongs, or a least offer an operation that allows to tell if an object belongs to a class.</p><p>Object state and operations are two separated things in the Sugar object-model:</p><ul><li>Objects have <span class='term'>slots</span> to which values can be <span class='term'>bound</span>. The state of an object, aka its attributes is implemented as values bound to slots.</li></ul><ul><li>Object operations, or <span class='term'>methods</span> are not necessarily implemented as functions bound to slots (this depends on the host language). Conceptually, an object responds to a message (method invocation), and the way it responds to this message it up to the object itself (that's the encapsulation principle) -- so it doesn't matter where the object looks into his slots or looks in a class definition to resolve the actual piece of code that makes up the operation.</li></ul><div class='annNote'><div class='title'>note</div><div class='content'>
  It's important to note that because of possible different implementations of
  attributes/operations, it's not allowed in Sugar to have an operation with the
  same name as an attribute.</div></div><p>Summary:</p><pre>     ---------------------
    |    OBJECT:CLASS     |       An OBJECT has a parent CLASS
    |---------------------|
    | SLOT=VALUE          |       The object SLOTS hold values for
    | SLOT=VALUE          |       the object ATTRIBUTES.
    | ...                 |
    |---------------------|
    | METHOD(...)         |       The object METHODS are MESSAGES
    | METHOD(...)         |       to which the object responds.
    | ...                 |
     ---------------------</pre></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">3<span class="lastDot dot">.</span></span></span>Class</h2><div class="level2"><p>As we just said, Sugar object model is <span class='term'>class-based</span>, meaning that you define abstractions by declaring a class. I won't go into the details of what a class is conceptually (there is plenty of good literature on that topic), but I can at least detail what a Sugar class is:</p><ul><li>A Sugar class is a collection of <span class='term'>attributes</span> and <span class='term'>method</span> declarations</li></ul></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">4<span class="lastDot dot">.</span></span></span>Protocols</h2><div class="level2"></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">3<span class="dot">.</span></span><span class="level1">5<span class="lastDot dot">.</span></span></span>Modules</h2><div class="level2"></div></div></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">4<span class="lastDot dot">.</span></span></span>Type system</h1><div class="level1"></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">5<span class="lastDot dot">.</span></span></span>Meta-programming</h1><div class="level1"><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">5<span class="dot">.</span></span><span class="level1">1<span class="lastDot dot">.</span></span></span>Embedding code</h2><div class="level2"></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">5<span class="dot">.</span></span><span class="level1">2<span class="lastDot dot">.</span></span></span>Specific sections</h2><div class="level2"></div></div><div class="section" level="2"><h2 class="heading"><span class="number"><span class="level0">5<span class="dot">.</span></span><span class="level1">3<span class="lastDot dot">.</span></span></span>Rewriting invocations</h2><div class="level2"></div></div></div></div><div class="section" level="1"><h1 class="heading"><span class="number"><span class="level0">6<span class="lastDot dot">.</span></span></span>Standard library</h1><div class="level1"></div></div></div></div>

</body>
</html>